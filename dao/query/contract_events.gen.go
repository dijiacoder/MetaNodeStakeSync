// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/dijiacoder/MetaNodeStakeSync/dao/model"
)

func newContractEvent(db *gorm.DB, opts ...gen.DOOption) contractEvent {
	_contractEvent := contractEvent{}

	_contractEvent.contractEventDo.UseDB(db, opts...)
	_contractEvent.contractEventDo.UseModel(&model.ContractEvent{})

	tableName := _contractEvent.contractEventDo.TableName()
	_contractEvent.ALL = field.NewAsterisk(tableName)
	_contractEvent.ID = field.NewInt64(tableName, "id")
	_contractEvent.ContractAddress = field.NewString(tableName, "contract_address")
	_contractEvent.EventName = field.NewString(tableName, "event_name")
	_contractEvent.Topic0 = field.NewString(tableName, "topic0")
	_contractEvent.Topic1 = field.NewString(tableName, "topic1")
	_contractEvent.Topic2 = field.NewString(tableName, "topic2")
	_contractEvent.Topic3 = field.NewString(tableName, "topic3")
	_contractEvent.Data = field.NewString(tableName, "data")
	_contractEvent.BlockNumber = field.NewUint64(tableName, "block_number")
	_contractEvent.BlockTimestamp = field.NewUint64(tableName, "block_timestamp")
	_contractEvent.TransactionHash = field.NewString(tableName, "transaction_hash")
	_contractEvent.LogIndex = field.NewInt32(tableName, "log_index")
	_contractEvent.CreatedAt = field.NewTime(tableName, "created_at")

	_contractEvent.fillFieldMap()

	return _contractEvent
}

// contractEvent Contract events table (unified)
type contractEvent struct {
	contractEventDo

	ALL             field.Asterisk
	ID              field.Int64
	ContractAddress field.String // Contract address
	EventName       field.String // Event name
	Topic0          field.String // Event signature hash
	Topic1          field.String // Indexed parameter 1
	Topic2          field.String // Indexed parameter 2
	Topic3          field.String // Indexed parameter 3
	Data            field.String // Event data (hex string)
	BlockNumber     field.Uint64 // Block number
	BlockTimestamp  field.Uint64 // Block timestamp
	TransactionHash field.String // Transaction hash
	LogIndex        field.Int32  // Log index in transaction
	CreatedAt       field.Time

	fieldMap map[string]field.Expr
}

func (c contractEvent) Table(newTableName string) *contractEvent {
	c.contractEventDo.UseTable(newTableName)
	return c.updateTableName(newTableName)
}

func (c contractEvent) As(alias string) *contractEvent {
	c.contractEventDo.DO = *(c.contractEventDo.As(alias).(*gen.DO))
	return c.updateTableName(alias)
}

func (c *contractEvent) updateTableName(table string) *contractEvent {
	c.ALL = field.NewAsterisk(table)
	c.ID = field.NewInt64(table, "id")
	c.ContractAddress = field.NewString(table, "contract_address")
	c.EventName = field.NewString(table, "event_name")
	c.Topic0 = field.NewString(table, "topic0")
	c.Topic1 = field.NewString(table, "topic1")
	c.Topic2 = field.NewString(table, "topic2")
	c.Topic3 = field.NewString(table, "topic3")
	c.Data = field.NewString(table, "data")
	c.BlockNumber = field.NewUint64(table, "block_number")
	c.BlockTimestamp = field.NewUint64(table, "block_timestamp")
	c.TransactionHash = field.NewString(table, "transaction_hash")
	c.LogIndex = field.NewInt32(table, "log_index")
	c.CreatedAt = field.NewTime(table, "created_at")

	c.fillFieldMap()

	return c
}

func (c *contractEvent) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := c.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (c *contractEvent) fillFieldMap() {
	c.fieldMap = make(map[string]field.Expr, 13)
	c.fieldMap["id"] = c.ID
	c.fieldMap["contract_address"] = c.ContractAddress
	c.fieldMap["event_name"] = c.EventName
	c.fieldMap["topic0"] = c.Topic0
	c.fieldMap["topic1"] = c.Topic1
	c.fieldMap["topic2"] = c.Topic2
	c.fieldMap["topic3"] = c.Topic3
	c.fieldMap["data"] = c.Data
	c.fieldMap["block_number"] = c.BlockNumber
	c.fieldMap["block_timestamp"] = c.BlockTimestamp
	c.fieldMap["transaction_hash"] = c.TransactionHash
	c.fieldMap["log_index"] = c.LogIndex
	c.fieldMap["created_at"] = c.CreatedAt
}

func (c contractEvent) clone(db *gorm.DB) contractEvent {
	c.contractEventDo.ReplaceConnPool(db.Statement.ConnPool)
	return c
}

func (c contractEvent) replaceDB(db *gorm.DB) contractEvent {
	c.contractEventDo.ReplaceDB(db)
	return c
}

type contractEventDo struct{ gen.DO }

type IContractEventDo interface {
	gen.SubQuery
	Debug() IContractEventDo
	WithContext(ctx context.Context) IContractEventDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IContractEventDo
	WriteDB() IContractEventDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IContractEventDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IContractEventDo
	Not(conds ...gen.Condition) IContractEventDo
	Or(conds ...gen.Condition) IContractEventDo
	Select(conds ...field.Expr) IContractEventDo
	Where(conds ...gen.Condition) IContractEventDo
	Order(conds ...field.Expr) IContractEventDo
	Distinct(cols ...field.Expr) IContractEventDo
	Omit(cols ...field.Expr) IContractEventDo
	Join(table schema.Tabler, on ...field.Expr) IContractEventDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IContractEventDo
	RightJoin(table schema.Tabler, on ...field.Expr) IContractEventDo
	Group(cols ...field.Expr) IContractEventDo
	Having(conds ...gen.Condition) IContractEventDo
	Limit(limit int) IContractEventDo
	Offset(offset int) IContractEventDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IContractEventDo
	Unscoped() IContractEventDo
	Create(values ...*model.ContractEvent) error
	CreateInBatches(values []*model.ContractEvent, batchSize int) error
	Save(values ...*model.ContractEvent) error
	First() (*model.ContractEvent, error)
	Take() (*model.ContractEvent, error)
	Last() (*model.ContractEvent, error)
	Find() ([]*model.ContractEvent, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ContractEvent, err error)
	FindInBatches(result *[]*model.ContractEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ContractEvent) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IContractEventDo
	Assign(attrs ...field.AssignExpr) IContractEventDo
	Joins(fields ...field.RelationField) IContractEventDo
	Preload(fields ...field.RelationField) IContractEventDo
	FirstOrInit() (*model.ContractEvent, error)
	FirstOrCreate() (*model.ContractEvent, error)
	FindByPage(offset int, limit int) (result []*model.ContractEvent, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IContractEventDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (c contractEventDo) Debug() IContractEventDo {
	return c.withDO(c.DO.Debug())
}

func (c contractEventDo) WithContext(ctx context.Context) IContractEventDo {
	return c.withDO(c.DO.WithContext(ctx))
}

func (c contractEventDo) ReadDB() IContractEventDo {
	return c.Clauses(dbresolver.Read)
}

func (c contractEventDo) WriteDB() IContractEventDo {
	return c.Clauses(dbresolver.Write)
}

func (c contractEventDo) Session(config *gorm.Session) IContractEventDo {
	return c.withDO(c.DO.Session(config))
}

func (c contractEventDo) Clauses(conds ...clause.Expression) IContractEventDo {
	return c.withDO(c.DO.Clauses(conds...))
}

func (c contractEventDo) Returning(value interface{}, columns ...string) IContractEventDo {
	return c.withDO(c.DO.Returning(value, columns...))
}

func (c contractEventDo) Not(conds ...gen.Condition) IContractEventDo {
	return c.withDO(c.DO.Not(conds...))
}

func (c contractEventDo) Or(conds ...gen.Condition) IContractEventDo {
	return c.withDO(c.DO.Or(conds...))
}

func (c contractEventDo) Select(conds ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.Select(conds...))
}

func (c contractEventDo) Where(conds ...gen.Condition) IContractEventDo {
	return c.withDO(c.DO.Where(conds...))
}

func (c contractEventDo) Order(conds ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.Order(conds...))
}

func (c contractEventDo) Distinct(cols ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.Distinct(cols...))
}

func (c contractEventDo) Omit(cols ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.Omit(cols...))
}

func (c contractEventDo) Join(table schema.Tabler, on ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.Join(table, on...))
}

func (c contractEventDo) LeftJoin(table schema.Tabler, on ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c contractEventDo) RightJoin(table schema.Tabler, on ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.RightJoin(table, on...))
}

func (c contractEventDo) Group(cols ...field.Expr) IContractEventDo {
	return c.withDO(c.DO.Group(cols...))
}

func (c contractEventDo) Having(conds ...gen.Condition) IContractEventDo {
	return c.withDO(c.DO.Having(conds...))
}

func (c contractEventDo) Limit(limit int) IContractEventDo {
	return c.withDO(c.DO.Limit(limit))
}

func (c contractEventDo) Offset(offset int) IContractEventDo {
	return c.withDO(c.DO.Offset(offset))
}

func (c contractEventDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IContractEventDo {
	return c.withDO(c.DO.Scopes(funcs...))
}

func (c contractEventDo) Unscoped() IContractEventDo {
	return c.withDO(c.DO.Unscoped())
}

func (c contractEventDo) Create(values ...*model.ContractEvent) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Create(values)
}

func (c contractEventDo) CreateInBatches(values []*model.ContractEvent, batchSize int) error {
	return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c contractEventDo) Save(values ...*model.ContractEvent) error {
	if len(values) == 0 {
		return nil
	}
	return c.DO.Save(values)
}

func (c contractEventDo) First() (*model.ContractEvent, error) {
	if result, err := c.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ContractEvent), nil
	}
}

func (c contractEventDo) Take() (*model.ContractEvent, error) {
	if result, err := c.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ContractEvent), nil
	}
}

func (c contractEventDo) Last() (*model.ContractEvent, error) {
	if result, err := c.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ContractEvent), nil
	}
}

func (c contractEventDo) Find() ([]*model.ContractEvent, error) {
	result, err := c.DO.Find()
	return result.([]*model.ContractEvent), err
}

func (c contractEventDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ContractEvent, err error) {
	buf := make([]*model.ContractEvent, 0, batchSize)
	err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (c contractEventDo) FindInBatches(result *[]*model.ContractEvent, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return c.DO.FindInBatches(result, batchSize, fc)
}

func (c contractEventDo) Attrs(attrs ...field.AssignExpr) IContractEventDo {
	return c.withDO(c.DO.Attrs(attrs...))
}

func (c contractEventDo) Assign(attrs ...field.AssignExpr) IContractEventDo {
	return c.withDO(c.DO.Assign(attrs...))
}

func (c contractEventDo) Joins(fields ...field.RelationField) IContractEventDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Joins(_f))
	}
	return &c
}

func (c contractEventDo) Preload(fields ...field.RelationField) IContractEventDo {
	for _, _f := range fields {
		c = *c.withDO(c.DO.Preload(_f))
	}
	return &c
}

func (c contractEventDo) FirstOrInit() (*model.ContractEvent, error) {
	if result, err := c.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ContractEvent), nil
	}
}

func (c contractEventDo) FirstOrCreate() (*model.ContractEvent, error) {
	if result, err := c.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ContractEvent), nil
	}
}

func (c contractEventDo) FindByPage(offset int, limit int) (result []*model.ContractEvent, count int64, err error) {
	result, err = c.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = c.Offset(-1).Limit(-1).Count()
	return
}

func (c contractEventDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = c.Count()
	if err != nil {
		return
	}

	err = c.Offset(offset).Limit(limit).Scan(result)
	return
}

func (c contractEventDo) Scan(result interface{}) (err error) {
	return c.DO.Scan(result)
}

func (c contractEventDo) Delete(models ...*model.ContractEvent) (result gen.ResultInfo, err error) {
	return c.DO.Delete(models)
}

func (c *contractEventDo) withDO(do gen.Dao) *contractEventDo {
	c.DO = *do.(*gen.DO)
	return c
}
